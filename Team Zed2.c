#pragma config(Sensor, dgtl1,  liftBottom,     sensorTouch)
#pragma config(Motor,  port1,           liftR3,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           liftR1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           liftR2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftL2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftL1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          liftL3,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void lift(int power){
	motor[liftL1]=power;
	motor[liftL2]=power;
	motor[liftL3]=power;
	motor[liftR1]=power;
	motor[liftR2]=power;
	motor[liftR3]=power;
}
void liftUp(){
	//PID with Jon
	wait1Msec(100);
}

void liftDown(){
	//PID with Jon
	wait1Msec(100);
}

void openIntake(){
	//PID with Jon
	wait1Msec(100);
}

void closeIntake(){
	//PID with Jon
	wait1Msec(100);
}

void liftAndIntake(){
	//PID with Jon
	liftUp();
	wait1Msec(100);
}

bool buttonPressUp=true;
bool buttonPressDown=true;
void lift(){
	if (vexRT[Btn5U] && buttonPressUp){
		liftAndIntake();
		buttonPressUp=false;
		buttonPressDown=true;
		wait1Msec(50);
	}
	else if(vexRT[Btn5U]){
		lift(127);
	}
	else if(SensorValue(liftBottom)==1){
		lift(0);
	}
	else if(vexRT[Btn5D] && buttonPressDown){
		liftDown();
		buttonPressDown=false;
		buttonPressUp=true;
		wait1Msec(50);
	}
	else if(vexRT[Btn5D]){
		lift(-127);
	}
	else{
		lift(7);
	}
}

void drive(){
	motor[rightDrive]=vexRT[Ch2];
	motor[leftDrive]=vexRT[Ch3];
}

bool applyPressure = false;
bool quickOpen=true;
bool quickClose=true;
void intaker(){
	if (vexRT[Btn6U] && quickClose){
		openIntake();
		applyPressure=true;
		quickClose=false;
		quickOpen=true;
		wait1Msec(50);
	}
	else if(vexRT[Btn6U]){
		motor[intake]=127;
		applyPressure = true;
		quickOpen=false;
		quickClose=true;
	}
	else if (vexRT[Btn6D] && quickOpen){
		closeIntake();
		applyPressure=false;
		quickOpen=true;
		quickClose=false;
		wait1Msec(50);
	}
	else if(vexRT[Btn6D]){
		motor[intake]=-100;
		applyPressure = false;
		quickOpen=false;
		quickClose=false;
	}
	else{
		motor[intake]=applyPressure*20;
	}
}

void drive(int power){
	motor[rightDrive]=power;
	motor[leftDrive]=power;
}

void resetEncoders(){
	nMotorEncoder[rightDrive]=0;
	nMotorEncoder[leftDrive]=0;
	nMotorEncoder[liftL1]=0;
}

void pre_auton() {
	resetEncoders();
}

void autonKnock(){
	lift(127);
	wait1Msec(200);
	lift(0);
	drive(127);
	wait1Msec(200);
	motor[intake]=127;
	wait1Msec(350);
	motor[intake]=0;
	wait1Msec(225);
	drive(0);
	lift(127);
	wait1Msec(350);
	drive(127);
	wait1Msec(400);
	lift(0);
	wait1Msec(450);
	drive(0);
	lift(127);
	wait1Msec(175);
	lift(0);
}

void autonCubeR() {
	closeIntake();
	lift(127);
	wait1Msec(150);
	lift(0);
	motor[intake]=0;
	while(nMotorEncoder(rightDrive)<25){
		motor[rightDrive]=128;
		delay(5);
	}
	while(nMotorEncoder(leftDrive)<150){
		drive(127);
		delay(5);
	}
	lift(-127);
	wait1Msec(100);
	lift(0);
	openIntake();
	while(nMotorEncoder(leftDrive)>125){
		drive(-127);
		delay(5);
	}
	closeIntake();
	lift(127);
	wait1Msec(100);
	lift(0);
	motor[intake]=15;
	while(nMotorEncoder(leftDrive)<-50){
		motor[leftDrive]=-127;
		delay(5);
	}
	while(nMotorEncoder(rightDrive)>-125){
		drive(-127);
		delay(5);
	}
	liftAndIntake();
	liftDown();
}

void autonCubeL(){
	closeIntake();
	lift(127);
	wait1Msec(100);
	lift(0);
	motor[intake]=0;
	while(nMotorEncoder(leftDrive)<25){
		motor[leftDrive]=128;
		delay(5);
	}
	while(nMotorEncoder(rightDrive)<150){
		drive(127);
		delay(5);
	}
	lift(-127);
	wait1Msec(100);
	lift(0);
	openIntake();
	while(nMotorEncoder(rightDrive)>125){
		drive(-127);
		delay(5);
	}
	closeIntake();
	lift(127);
	wait1Msec(100);
	lift(0);
	motor[intake]=15;
	while(nMotorEncoder(rightDrive)<-50){
		motor[rightDrive]=-127;
		delay(5);
	}
	while(nMotorEncoder(leftDrive)>-125){
		drive(-127);
		delay(5);
	}
	liftAndIntake();
	liftDown();
}
int choice=0;
task autonomous {
	if(choice==1){
		autonKnock();
	}
	else if (choice==2){
		autonCubeR();
	}
	else if(choice==3){
		autonCubeL();
	}
}

task usercontrol(){
	while(true){
		drive();
		lift();
		intaker();
		wait1Msec(10);
	}
}
